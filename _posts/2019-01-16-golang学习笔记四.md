---
layout:     post
title:      Golang学习笔记四
subtitle:   数组与切片
date:       2019-01-16
author:     CDz
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Golang
---

# 数组

## 创建数组

- 定义数组也准寻golang的基本定义习惯,变量类型在前,变量名在后

```
/**
创建一个数组
 */
func createArrays() {
    //第一种 定义数组 
    var arr1 [5]int  //不指定数组值,默认int为0

    //第二种 定义数组方式
    arr2 := [3]int{1, 2, 3} //设置初始值

    //可变长度的数组
    arr3 := [...]int{1, 2, 3, 4, 5}

    //二维数组
    var arr4 [4][5]int //创建一个4行,5列的二维数组
}
```

## 遍历数组

- 遍历数组可以使用原始的fori形式,但是一般不这么做,golang中定义关键字`range`可以遍历数组
- 为什么使用`range`
    + 意义明确,美观
    + c++没有这个能力
    + java/python中有类似的for each value 但是不能同时取出 k ,v

```
    //原始fori的形式
    for i:=0;i< len(arr3);i++  {
        fmt.Println(arr3[i])
    }

//遍历 之遍历出值 使用range关键字
    for e := range arr3 {
        fmt.Println(e)
    }

    //关键字range遍历出 下标与值
    for k, v := range arr3 {
        //k下标 v 值
        fmt.Println(k,v)
    }
```

## 数组是值类型

- 注意这一点与Java不同,在Java中数组是`引用类型`([Golang学习笔记三](https://cdz1129.github.io/2019/01/14/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/#java%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92)有复习到Java中值类型与引用类型)
- 值类型意味着,传递参数时数组是拷贝份,被调用函数中修改数组调用方法上不会被修改

**golang值传递方式实验**
```
func printArr(ints [5]int) { //使用数组作为参数,就需要指定数量 ,
    //[5]int类型如果传入[3]int就会报错.
    //如果不想被数量限制可以使用 [...]int作为参数类型
    for k, v := range ints {
        fmt.Println(k, v)
    }
}

func updateArr(ints [5]int) {
    ints[0] = 1000
    fmt.Println("-------------update success----------")
}

func main() {
    arr3 := [...]int{1, 2, 3, 4, 5}
    printArr(arr3)
    fmt.Println("---------------update before--------------")
    updateArr(arr3)
    fmt.Println("---------------update after--------------")
    printArr(arr3)
}
```
打印结果:
```
0 1
1 2
2 3
3 4
4 5
---------------update before--------------
-------------update success----------
---------------update after--------------
0 1 //下标0发现确实是没有改变的
1 2
2 3
3 4
4 5
```

**golang指针传递方式**
```
func updateArrByPointer(ints *[5]int) {
    ints[0] = 1000  //可以发现在golang中使用数组指针,直接使用变量名就好不需要再`*ints`来转换
    fmt.Println("-------------update success----------")
}
func main() {
    arr3 := [...]int{1, 2, 3, 4, 5}
    printArr(arr3)
    fmt.Println("---------------update before--------------")
    updateArrByPointer(&arr3) //传入arr指针
    fmt.Println("---------------update after--------------")
    printArr(arr3)
}
```
打印结果:
```
0 1
1 2
2 3
3 4
4 5
---------------update before--------------
-------------update success----------
---------------update after--------------
0 1000  //修改成功
1 2
2 3
3 4
4 5
```

**对比Java修改数组**

以下为Java代码
```
@Test
public void testAdd(){
    int[] ints = new int[5];//Java创建数组,初始不指定初始全部为0
    updateArr(ints);
    System.out.println(Arrays.toString(ints)); //打印结果[100, 0, 0, 0, 0]
}

private void updateArr(int[] ints) {
        ints[0]=100;
}
```

**小结**

- [10]int与[5]int是不同类型
- go语言中数组为*值类型*,Java中数组为*引用类型*,调用`fun f(arr [10]int)`会 *拷贝* 数组
- 因为这些麻烦,一般在go语言中不直接使用数组,而是使用 *切片*

# slice(切片)

## 如何定义一个slice
```
    arr := [...]int{0,1,2,3,4,5,6,7}
    s1 := arr[2:6]// [3 4 5 6]左闭右开,一般计算机语言中都是这么定义
    //slice不是值类型,底层是对其数组的封装
```

由上可知,slice定义是int[:] 关键是在数组括号中加上`:`冒号,更多定义形式:

```
func main() {
    arr := [...]int{0,1,2,3,4,5,6,7}
    s1 := arr[2:6]// [3 4 5 6]左闭右开,一般计算机语言中都是这么定义
    //slice不是值类型,底层是对其数组的封装
    fmt.Println("arr[2:6]:",s1)
    s2 := arr[:6]
    fmt.Println("arr[:6]:", s2)
    s3 := arr[2:]
    fmt.Println("arr[2:]:", s3)
    s4 := arr[:]
    fmt.Println("arr[:]:", s4)
}
```
打印信息:
```
arr[2:6]: [2 3 4 5]         //当左右都限制数字时,打印截取的是arr的下标 [2,5)元素,左闭右开
arr[:6]: [0 1 2 3 4 5]      //当不限制左边,不填写左边数字,实际打印截取arr下标[0,6)元素
arr[2:]: [2 3 4 5 6 7]      //不限制右边,不填写右边数字,实际打印截取arr下标[2,8)
arr[:]: [0 1 2 3 4 5 6 7]   //两边都不限制时,截取所有
```

## 如何使用slice

### slice修改数组

在调用函数中修改切片内容
```
func updateSlice(ints []int) { //[]int 表示slice类型
    ints[2] = 100
}

func main() {
    arr := [...]int{0,1,2,3,4,5,6,7}
    s1 := arr[2:6]// [3 4 5 6]左闭右开,一般计算机语言中都是这么定义
    //slice不是值类型,底层是对其数组的封装
    s2 := arr[:6]
    s3 := arr[2:]
    s4 := arr[:]
    fmt.Println("s1:",s1)
    fmt.Println("------------updateSlice before----------")
    updateSlice(s1) //修改slice s1
    fmt.Println("------------updateSlice after----------")
    fmt.Println("s1:",s1)
    fmt.Println("s2:",s2)
    fmt.Println("s3:",s3)
    fmt.Println("s4:",s4)
    fmt.Println("arr:",arr)
    /**
     - slice不是值类型,go语言中除了slice所有都是值类型(slice的特殊之处就提现在这个地方)
        - slice在内部,是有一个数据结构的,是对arr的一个view(视图)
     */
}
```
控制台打印为:
```
s1: [2 3 4 5]
------------updateSlice before----------
------------updateSlice after----------
s1: [2 3 100 5]
s2: [0 1 2 3 100 5]
s3: [2 3 100 5 6 7]
s4: [0 1 2 3 100 5 6 7]
arr: [0 1 2 3 100 5 6 7]
```

奇妙的事情发生了,所有视图中,对应的arr下标中第4个元素都被修改成了100,由此实验,我们也可以更好的理解什么叫做slice为对应数组的视图.

如果觉得不懂我们可以一步步推导一下:

1. `s1 := arr[2:6]// [3 4 5 6]` s1[2] 对应的 arr[4]
2. `fun updateSlice`中将s1[2]修改成100,视图(顾名思义对arr数组的引用,而不是拷贝),所以对应的arr[4]被赋值为100(这里是语言表达便于,其实arr[4]就是s1[2]).
3. 接着因为s2是对arr的[0,6)的视图,故arr[4]就是s2[4],所以s2[4]=100.
4. 其他s3,s4同理


### reslice

reslice顾名思义,就是在slice的基础上继续slice

```
func main() {
     arr := [...]int{0,1,2,3,4,5,6,7}
     s4 := arr[:]
     fmt.Println("arr[:]:", s4)
     s4 = s4[:6]
     fmt.Println("reslice 1 s4:",s4)
     s4 = s4[2:]
     fmt.Println("reslice 2 s4:",s4)
}
```

控制台打印
```
arr[:]: [0 1 2 3 4 5 6 7] 
reslice 1 s4: [0 1 2 3 4 5]
reslice 2 s4: [2 3 4 5] 
```

### slice的拓展

思考下面代码会如何打印?

```
func main() {
    //拓展
    arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
    s1 := arr[2:6] 
    s2 := s1[3:5]
    fmt.Println("s1,s2:",s1,s2)
}
```

先猜测一下,s1我们知道很简单[2 3 4 5],但是s2是对s1的slice而s1只有4个元素最大下标为3,s2却要取到其下标4,能否成功呢?

先执行看结果:
```
s1,s2: [2 3 4 5] [5 6] //打印结果是没有报错的,而且从结果分析,s1的第4下标元素是arr的第6下标
```

尝试打印s1[4]是否成功
```
    fmt.Println("s1[4]",s1[4])
```
可以看到报错是不能打印下标4元素的
```
panic: runtime error: index out of range

goroutine 1 [running]:
main.main()
    D:/IdeaProduct/learngo/container/slices.go:54 +0x15c
```

所以这里就需要引出slice的底层数据结构来解释:

slice底层数据结构:

![slice底层数据结构](http://wx4.sinaimg.cn/large/63d77fe7gy1fz8o3llof9j20ky0axjre.jpg)

slice拓展过程:

![slice拓展过程](http://wx3.sinaimg.cn/large/63d77fe7gy1fz8o3pgi8nj20n907mq2v.jpg)


len() cap()分别指什么位置,ptr指的是什么

slice其他操作,添加元素

append
copy
delete(删除中间,删除头 尾)


## 总结slice是什么

