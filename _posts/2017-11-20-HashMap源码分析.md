---
layout:     post
title:      Java8-HashMap原理分析
subtitle:   HashMap源码分析
date:       2017-11-20
author:     CDz
header-img: img/post-bg-os-metro.jpg
catalog: true
tags:
    - 算法
    - Java
    - HashMap
    - JDK1.8源码
---
# HashMap概述
HashMap在`java`的`java.util`包下的属于基本数据容器类，以`key-value`的形式来作为基本的数据结构。特性为 `key`唯一且可为`null`，`value`值可重复可为`null`。

值得注意的是HashMap是线程不安全的，如果想要线程安全的map，可以使用`Collections.synchronizedMap(hashmap)`，或者使用`ConcurrentMap<K,T>()`接口下实现的map，尽量避免使用`hashtable`如果在多线程情况下，因为其是全局线程锁的，对性能消耗比较大。

继承的抽象类：`AbstractMap<K,V>`

实现的接口：`Map<K,V>`,`Cloneable`,`Serializable`

接口的实现说明，1.属于顶级Map父接口 2.可复制 3.可序列化

其中`Cloneable`接口很值得说一下，它是一个空接口，其是作为一个**申明式**接口，也是看源码学习到的一个编程思想，通过类所实现的接口来说明其类有什么功能。所以可以在项目中创建一些空接口语义具体来且普遍来供其它类来实现，说明实现类有哪些功能。

~哈哈，扯得有点远了，下面正式进入HashMap的源码与原理分析中。

# HashMap实现原理
先用一张图来简单解释一下HashMap内部结构

![HashMap内部实现简单图解](http://wx2.sinaimg.cn/large/63d77fe7gy1flup2s4lexj20ir0eeabl.jpg)

HashMap内部是以一个散列表+链表的结构。而在JDK1.8之后多HashMap有所变化，是以散列表+链表（而当链表数量达到8后，会以红黑树的形式替代链表）

明白了内部实现之后，聪明的你一定想到了，java到底是如何将各种不同类型的key放入桶中的呢，还有为什么要用这么复杂的结构来存入数据结构，直接用数组不行吗？等等...这些疑问我会在源码中一一讲解。
# HashMap源码分析
## 关键字段
```
transient Node<K,V>[] table;//散列表，存放实体元素的数组
transient int size;//数组的长度
transient int modCount;//修改的次数（用于fail-fast）
int threshold;//临界值 临界值 = 加载因子 * 数组长度
final float loadFactor;//加载因子 

//默认参数
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; 
static final int MAXIMUM_CAPACITY = 1 << 30;
static final float DEFAULT_LOAD_FACTOR = 0.75f;
static final int TREEIFY_THRESHOLD = 8;


```
## 构造函数

## 数据存储（原理实现）

### java8红黑树优化哈系桶

## 大小调整

## 数据读取

## 构造函数中参数使用

# HashMap小细节

## HashMap快速失败

## transient字段

## clone方法浅复制